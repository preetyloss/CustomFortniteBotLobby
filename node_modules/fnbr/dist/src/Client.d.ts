/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import Auth from './auth/Auth';
import Http from './http/HTTP';
import AsyncLock from './util/AsyncLock';
import XMPP from './xmpp/XMPP';
import CreatorCode from './structures/CreatorCode';
import ClientParty from './structures/party/ClientParty';
import Party from './structures/party/Party';
import SentPartyJoinRequest from './structures/party/SentPartyJoinRequest';
import RadioStation from './structures/RadioStation';
import Stats from './structures/Stats';
import NewsMessage from './structures/NewsMessage';
import FortniteServerStatus from './structures/FortniteServerStatus';
import EpicgamesServerStatus from './structures/EpicgamesServerStatus';
import TournamentManager from './managers/TournamentManager';
import UserManager from './managers/UserManager';
import FriendManager from './managers/FriendManager';
import STWManager from './managers/STWManager';
import EOSConnect from './stomp/EOSConnect';
import ChatManager from './managers/ChatManager';
import type { CreativeIslandData, CreativeDiscoveryPanel } from '../resources/httpResponses';
import type { ClientOptions, ClientConfig, ClientEvents, PartyConfig, Schema, Region, BlurlStream, Language, PartyData, PresenceOnlineType, BRAccountLevelData } from '../resources/structs';
/**
 * Represents the main client
 */
declare class Client extends EventEmitter {
    /**
     * Timeouts set by {@link Client#setTimeout} that are still active
     */
    private timeouts;
    /**
     * Intervals set by {@link Client#setInterval} that are still active
     */
    private intervals;
    /**
     * All client configuration options
     */
    config: ClientConfig;
    /**
     * Authentication manager
     */
    auth: Auth;
    /**
     * Lock used to pause certain incoming xmpp messages while the bots party is being modified
     */
    partyLock: AsyncLock;
    /**
     * Lock used to pause xmpp presences while the friend caches are being populated
     */
    cacheLock: AsyncLock;
    /**
     * HTTP manager
     */
    http: Http;
    /**
     * User manager
     */
    user: UserManager;
    /**
     * Whether the client is fully started
     */
    isReady: boolean;
    /**
     * XMPP manager
     */
    xmpp: XMPP;
    /**
     * EOS Connect STOMP manager
     */
    stompEOSConnect: EOSConnect;
    /**
     * Friend manager
     */
    friend: FriendManager;
    /**
     * The client's current party
     */
    party?: ClientParty;
    /**
     * The client's tournament manager.
     */
    tournaments: TournamentManager;
    /**
     * The last saved client party member meta
     */
    lastPartyMemberMeta?: Schema;
    /**
     * Fortnite: Save The World manager
     */
    stw: STWManager;
    /**
     * EOS: Chat Manager
     */
    chat: ChatManager;
    /**
     * @param config The client's configuration options
     */
    constructor(config?: ClientOptions);
    on<U extends keyof ClientEvents>(event: U, listener: ClientEvents[U]): this;
    once<U extends keyof ClientEvents>(event: U, listener: ClientEvents[U]): this;
    emit<U extends keyof ClientEvents>(event: U, ...args: Parameters<ClientEvents[U]>): boolean;
    /**
     * Logs the client in.
     * A valid authentication method must be provided in the client's config.
     * By default, there will be a console prompt asking for an authorization code
     * @throws {EpicgamesAPIError}
     * @throws {EpicgamesGraphQLError}
     */
    login(): Promise<void>;
    /**
     * Logs the client out.
     * Also clears all caches, etc
     */
    logout(): Promise<void>;
    /**
     * Restarts the client
     */
    restart(): Promise<void>;
    /**
     * Initializes {@link Client#party}
     * @param createNew Whether to create a new party
     * @param forceNew Whether to force create a new party
     */
    initParty(createNew?: boolean, forceNew?: boolean): Promise<void>;
    /**
     * Internal method that sets a {@link ClientParty} to the value of {@link Client#party}
     * @param party The party
     * @private
     */
    setClientParty(party: Party): void;
    /**
     * Waits until the client is ready
     * @param timeout How long to wait for until an error is thrown
     */
    waitUntilReady(timeout?: number): Promise<void>;
    /**
     * Cleanup method
     */
    private destroy;
    /**
     * Initializes the sweeping of cached objects
     */
    private initCacheSweeping;
    /**
     * Updates the client's caches
     */
    updateCaches(): Promise<void>;
    /**
     * Removes presences from the client's cache that are older than the max lifetime
     * @param maxLifetime How old a presence cache entry must be before it can be sweeped (in seconds)
     * @returns The amount of presences sweeped
     */
    sweepPresences(maxLifetime?: number | undefined): number;
    /**
     * Removes users from the client's cache that are older than the max lifetime
     * @param maxLifetime How old a user cache entry must be before it can be sweeped (in seconds)
     * @returns The amount of users sweeped
     */
    sweepUsers(maxLifetime?: number | undefined): number;
    /**
     * Wait until an event is emitted
     * @param event The event that will be waited for
     * @param timeout The timeout (in milliseconds)
     * @param filter The filter for the event
     */
    waitForEvent<U extends keyof ClientEvents>(event: U, timeout?: number, filter?: (...args: Parameters<ClientEvents[U]>) => boolean): Promise<Parameters<ClientEvents[U]>>;
    /**
     * Sets a timeout that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait before executing (in milliseconds)
     * @param args Arguments for the function
     */
    setTimeout(fn: (...args: any) => any, delay: number, ...args: any): NodeJS.Timeout;
    /**
     * Clears a timeout
     * @param timeout Timeout to cancel
     */
    clearTimeout(timeout: NodeJS.Timeout): void;
    /**
     * Sets an interval that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait between executions (in milliseconds)
     * @param args Arguments for the function
     */
    setInterval(fn: (...args: any) => any, delay: number, ...args: any): NodeJS.Timer;
    /**
     * Clears an interval.
     * @param interval Interval to cancel
     */
    clearInterval(interval: NodeJS.Timeout): void;
    static consoleQuestion(question: string): Promise<string>;
    /**
     * Debug a message using the methods set in the client config
     * @param message Text to debug
     * @param type Debug type (regular, http or xmpp)
     */
    debug(message: string, type?: 'regular' | 'http' | 'xmpp' | 'eos-connect'): void;
    /**
     * Sets the clients XMPP status
     * @param status The status
     * @param onlineType The presence's online type (eg "away")
     * @param friend A specific friend you want to send this status to
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     */
    setStatus(status?: string, onlineType?: PresenceOnlineType, friend?: string): void;
    /**
     * Resets the client's XMPP status and online type
     */
    resetStatus(): Promise<void>;
    /**
     * Sends a party invitation to a friend
     * @param friend The friend that will receive the invitation
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {PartyNotFoundError} The client is not in party
     * @throws {EpicgamesAPIError}
     */
    invite(friend: string): Promise<import("./structures/party/SentPartyInvitation").default>;
    /**
     * Joins a party by its id
     * @param id The party id
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched
     * @throws {PartyMaxSizeReachedError} The party has reached its max size
     * @throws {EpicgamesAPIError}
     */
    joinParty(id: string): Promise<void>;
    /**
     * Creates a new party
     * @param config The party config
     * @throws {EpicgamesAPIError}
     */
    createParty(config?: PartyConfig): Promise<void>;
    /**
     * Leaves the client's current party
     * @param createNew Whether a new party should be created
     * @throws {EpicgamesAPIError}
     */
    leaveParty(createNew?: boolean): Promise<void>;
    /**
     * Sends a party join request to a friend.
     * When the friend confirms this, a party invite will be sent to the client
     * @param friend The friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyNotFoundError} The friend is not in a party
     * @throws {EpicgamesAPIError}
     */
    sendRequestToJoin(friend: string): Promise<SentPartyJoinRequest>;
    /**
     * Fetches the client's party
     * @throws {EpicgamesAPIError}
     */
    getClientParty(): Promise<ClientParty | undefined>;
    /**
     * Fetches a party by its id
     * @param id The party's id
     * @param raw Whether to return the raw party data
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched due to a permission error
     * @throws {EpicgamesAPIError}
     */
    getParty(id: string, raw?: boolean): Promise<Party | PartyData>;
    /**
     * Fetches the current Fortnite server status (lightswitch)
     * @throws {EpicgamesAPIError}
     */
    getFortniteServerStatus(): Promise<FortniteServerStatus>;
    /**
     * Fetches the current epicgames server status (https://status.epicgames.com/)
     * @throws {AxiosError}
     */
    getEpicgamesServerStatus(): Promise<EpicgamesServerStatus>;
    /**
     * Fetches the current Fortnite storefronts
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    getStorefronts(language?: Language): Promise<any>;
    /**
     * Downloads a blurl stream (eg a radio station stream or a news video)
     * @param id The stream ID
     * @throws {AxiosError}
     */
    downloadBlurlStream(id: string): Promise<BlurlStream>;
    getBRStats(user: string, startTime?: number, endTime?: number): Promise<Stats>;
    getBRStats(user: string[], startTime?: number, endTime?: number, stats?: string[]): Promise<Stats[]>;
    /**
     * Fetches the current Battle Royale news
     * @param language The language of the news
     * @param customPayload Extra data to send in the request body for a personalized news response (battle pass level, country, etc)
     * @throws {EpicgamesAPIError}
     */
    getBRNews(language?: "en", customPayload?: any): Promise<NewsMessage[]>;
    /**
     * Fetches data for a Support-A-Creator code
     * @param code The Support-A-Creator code (slug)
     * @throws {CreatorCodeNotFoundError} The Support-A-Creator code wasnt found
     * @throws {EpicgamesAPIError}
     */
    getCreatorCode(code: string): Promise<CreatorCode>;
    /**
     * Fetches the current Fortnite Battle Royale radio stations
     * @throws {EpicgamesAPIError}
     */
    getRadioStations(): Promise<RadioStation[]>;
    /**
     * Fetches the current Battle Royale event flags
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    getBREventFlags(language?: Language): Promise<any>;
    /**
     * Fetches the Battle Royale account level for one or multiple users
     * @param user The id(s) and/or display name(s) of the user(s) to fetch the account level for
     * @param seasonNumber The season number (eg. 16, 17, 18)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {EpicgamesAPIError}
     */
    getBRAccountLevel(user: string | string[], seasonNumber: number): Promise<BRAccountLevelData[]>;
    /**
     * Fetches the storefront keychain
     * @throws {EpicgamesAPIError}
     */
    getStorefrontKeychain(): Promise<string[]>;
    /**
     * Fetches a creative island by its code
     * @param code The island code
     * @throws {CreativeIslandNotFoundError} A creative island with the provided code does not exist
     * @throws {EpicgamesAPIError}
     */
    getCreativeIsland(code: string): Promise<CreativeIslandData>;
    /**
     * Fetches the creative discovery surface
     * @param gameVersion The current game version (MAJOR.MINOR)
     * @throws {EpicgamesAPIError}
     */
    getCreativeDiscoveryPanels(gameVersion: string | undefined, region: Region): Promise<CreativeDiscoveryPanel[]>;
}
export default Client;
