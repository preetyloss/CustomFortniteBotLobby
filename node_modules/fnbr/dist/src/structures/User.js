"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Base_1 = tslib_1.__importDefault(require("../client/Base"));
const UserNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/UserNotFoundError"));
/**
 * Represents a user
 */
class User extends Base_1.default {
    /**
     * @param client The main client
     * @param data The user's data
     */
    constructor(client, data) {
        super(client);
        this._displayName = data.displayName;
        this.id = data.id;
        this.externalAuths = data.externalAuths || {};
        // For some reason, no external auths = empty array
        if (Array.isArray(this.externalAuths))
            this.externalAuths = {};
    }
    /**
     * The user's display name (In case its undefined, use {@link User#fetch})
     */
    get displayName() {
        return this._displayName || (Object.values(this.externalAuths)[0] && Object.values(this.externalAuths)[0].externalDisplayName);
    }
    /**
     * Whether the user is headless (the account is not actually an epicgames account)
     */
    get isHeadless() {
        return !this._displayName;
    }
    /**
     * Sends a friendship request to this user or accepts an existing one
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {DuplicateFriendshipError} The user is already friends with the client
     * @throws {FriendshipRequestAlreadySentError} A friendship request has already been sent to the user
     * @throws {InviterFriendshipsLimitExceededError} The client's friendship limit is reached
     * @throws {InviteeFriendshipsLimitExceededError} The user's friendship limit is reached
     * @throws {InviteeFriendshipSettingsError} The user disabled friend requests
     * @throws {InviteeFriendshipRequestLimitExceededError} The user's incoming friend request limit is reached
     * @throws {EpicgamesAPIError}
     */
    async addFriend() {
        return this.client.addFriend(this.id);
    }
    /**
     * Blocks this user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async block() {
        return this.client.blockUser(this.id);
    }
    /**
     * Updates this user's display name and external auths
     * @throws {UserNotFoundError} The user wasn't found
     */
    async fetch() {
        const user = await this.client.getProfile(this.id);
        if (!user)
            throw new UserNotFoundError_1.default(this.id);
        this.update(user);
    }
    /**
     * Fetches battle royale v2 stats for this user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {EpicgamesAPIError}
     */
    async getBRStats(startTime, endTime) {
        return this.client.getBRStats(this.id, startTime, endTime);
    }
    /**
     * Fetches the battle royale account level for this user
     * @param seasonNumber The season number (eg. 16, 17, 18)
     */
    async getBRAccountLevel(seasonNumber) {
        return (await this.client.getBRAccountLevel(this.id, seasonNumber))[0].level;
    }
    /**
     * Fetches the avatar for this user
     * @throws {EpicgamesAPIError}
     */
    async getAvatar() {
        return (await this.client.getUserAvatar(this.id))[0];
    }
    /**
     * Fetches the global profile for this user
     * @throws {EpicgamesAPIError}
     */
    async getGlobalProfile() {
        return (await this.client.getGlobalProfile(this.id))[0];
    }
    /**
     * Fetches the event tokens for an account.
     * This can be used to check if a user is eligible to play a certain tournament window
     * or to check a user's arena division in any season
     * @throws {EpicgamesAPIError}
     */
    async getEventTokens() {
        return (await this.client.getEventTokens(this.id))[0];
    }
    /**
     * Updates this user with the given data
     * @param data The updated user data
     */
    update(data) {
        this._displayName = data.displayName;
        this.externalAuths = data.externalAuths || {};
        if (Array.isArray(this.externalAuths))
            this.externalAuths = {};
    }
    /**
     * The raw user data
     */
    toObject() {
        return {
            id: this.id,
            displayName: this._displayName,
            externalAuths: this.externalAuths,
        };
    }
}
exports.default = User;
//# sourceMappingURL=User.js.map