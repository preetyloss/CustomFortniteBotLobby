"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable class-methods-use-this */
/* eslint-disable no-restricted-syntax */
const Base_1 = tslib_1.__importDefault(require("../Base"));
const Util_1 = require("../util/Util");
const constants_1 = require("../../resources/constants");
/**
 * Represents a user's battle royale stats
 */
class Stats extends Base_1.default {
    /**
     * @param client The main client
     * @param data The stats' data
     */
    constructor(client, data, user) {
        super(client);
        this.data = data;
        this.user = user;
        this.startTime = new Date(data.startTime / 1000);
        this.endTime = new Date(data.endTime / 1000);
        this.levelData = {};
        this.stats = {
            all: (0, Util_1.createDefaultInputTypeStats)(),
            keyboardmouse: (0, Util_1.createDefaultInputTypeStats)(),
            gamepad: (0, Util_1.createDefaultInputTypeStats)(),
            touch: (0, Util_1.createDefaultInputTypeStats)(),
        };
        for (const key of Object.keys(data.stats)) {
            if (constants_1.statsKeyRegex.test(key)) {
                const [, statKey, inputType, playlistId] = key
                    .match(constants_1.statsKeyRegex);
                const playlistType = typeof this.client.config.statsPlaylistTypeParser === 'function'
                    ? this.client.config.statsPlaylistTypeParser(playlistId)
                    : this.getPlaylistStatsType(playlistId);
                if (playlistType !== 'other') {
                    const [parsedKey, parsedValue] = (0, Util_1.parseStatKey)(statKey, data.stats[key]);
                    const inputTypePlaylistStats = this.stats[inputType][playlistType];
                    const inputTypeAllStats = this.stats[inputType].overall;
                    const allPlaylistStats = this.stats.all[playlistType];
                    const allAllStats = this.stats.all.overall;
                    if (parsedKey === 'lastModified') {
                        if (!inputTypePlaylistStats.lastModified || parsedValue.getTime() > inputTypePlaylistStats.lastModified.getTime()) {
                            inputTypePlaylistStats.lastModified = parsedValue;
                        }
                        if (!inputTypeAllStats.lastModified || parsedValue.getTime() > inputTypeAllStats.lastModified.getTime()) {
                            inputTypeAllStats.lastModified = parsedValue;
                        }
                        if (!allPlaylistStats.lastModified || parsedValue.getTime() > allPlaylistStats.lastModified.getTime()) {
                            allPlaylistStats.lastModified = parsedValue;
                        }
                        if (!allAllStats.lastModified || parsedValue.getTime() > allAllStats.lastModified.getTime()) {
                            allAllStats.lastModified = parsedValue;
                        }
                    }
                    else {
                        inputTypePlaylistStats[parsedKey] += parsedValue;
                        if (playlistType !== 'ltm')
                            inputTypeAllStats[parsedKey] += parsedValue;
                        allPlaylistStats[parsedKey] += parsedValue;
                        if (playlistType !== 'ltm')
                            allAllStats[parsedKey] += parsedValue;
                    }
                }
            }
            else if (/^s\d\d?_social_bp_level$/.test(key)) {
                this.levelData[key.split('_')[0]] = {
                    level: Math.round(data.stats[key] / 100),
                    progress: data.stats[key] % 100,
                };
            }
        }
        for (const inputTypes of Object.keys(this.stats)) {
            for (const playlistTypeStats of Object.values(this.stats[inputTypes])) {
                playlistTypeStats.deaths = playlistTypeStats.matches - playlistTypeStats.wins;
                playlistTypeStats.kd = playlistTypeStats.kills / (playlistTypeStats.deaths || 1);
                playlistTypeStats.killsPerMin = playlistTypeStats.kills / (playlistTypeStats.minutesPlayed || 1);
                playlistTypeStats.killsPerMatch = playlistTypeStats.kills / (playlistTypeStats.matches || 1);
                playlistTypeStats.scorePerMin = playlistTypeStats.score / (playlistTypeStats.minutesPlayed || 1);
                playlistTypeStats.scorePerMatch = playlistTypeStats.score / (playlistTypeStats.matches || 1);
                playlistTypeStats.winRate = playlistTypeStats.wins / (playlistTypeStats.matches || 1);
            }
        }
    }
    /**
     * Returns the playlist stats type by the playlist id
     * @param playlistID The playlist ID
     */
    getPlaylistStatsType(playlistID) {
        const playlist = playlistID.toLowerCase().replace('playlist_', '');
        if (['creative', 'respawn', '16'].some((s) => playlist.includes(s)))
            return 'other';
        if (!['default', 'classic', 'showdown', 'vamp',
            'unvaulted', 'toss', 'fill', 'heavy', 'tank', 'melt'].some((s) => playlist.includes(s)))
            return 'ltm';
        if (playlist.includes('solo'))
            return 'solo';
        if (playlist.includes('duo'))
            return 'duo';
        if (playlist.includes('trio'))
            return 'squad';
        if (playlist.includes('squad'))
            return 'squad';
        return 'other';
    }
}
exports.default = Stats;
//# sourceMappingURL=Stats.js.map