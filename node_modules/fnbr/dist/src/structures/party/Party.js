"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const collection_1 = require("@discordjs/collection");
const Endpoints_1 = tslib_1.__importDefault(require("../../../resources/Endpoints"));
const Enums_1 = require("../../../enums/Enums");
const Base_1 = tslib_1.__importDefault(require("../../Base"));
const PartyAlreadyJoinedError_1 = tslib_1.__importDefault(require("../../exceptions/PartyAlreadyJoinedError"));
const Util_1 = require("../../util/Util");
const ClientPartyMember_1 = tslib_1.__importDefault(require("./ClientPartyMember"));
const PartyMember_1 = tslib_1.__importDefault(require("./PartyMember"));
const PartyMeta_1 = tslib_1.__importDefault(require("./PartyMeta"));
const enums_1 = require("../../../resources/enums");
/**
 * Represents a party that the client is not a member of
 */
class Party extends Base_1.default {
    /**
     * @param client The main client
     * @param data The party's data
     */
    constructor(client, data) {
        super(client);
        this.id = data.id;
        this.createdAt = new Date(data.created_at);
        this.config = (0, Util_1.makeCamelCase)(data.config);
        this.config.privacy = this.config.joinability === 'OPEN' ? Enums_1.PartyPrivacy.PUBLIC : Enums_1.PartyPrivacy.PRIVATE;
        this.meta = new PartyMeta_1.default(data.meta);
        this.revision = data.revision || 0;
        this.members = new collection_1.Collection(data.members.map((m) => {
            if (m.account_id === this.client.user.self.id)
                return [m.account_id, new ClientPartyMember_1.default(this, m)];
            return [m.account_id, new PartyMember_1.default(this, m)];
        }));
    }
    /**
     * The party's member count
     */
    get size() {
        return this.members.size;
    }
    /**
     * The party's max member count
     */
    get maxSize() {
        return this.config.maxSize;
    }
    /**
     * The party's leader
     */
    get leader() {
        return this.members.find((m) => m.role === 'CAPTAIN');
    }
    /**
     * The currently selected playlist
     */
    get playlist() {
        return this.meta.island;
    }
    /**
     * The custom matchmaking key
     */
    get customMatchmakingKey() {
        return this.meta.customMatchmakingKey;
    }
    /**
     * The squad fill status
     */
    get squadFill() {
        return this.meta.squadFill;
    }
    /**
     * Joins this party
     * @param skipRefresh Whether to skip refreshing the party data (Only use this if you know what you're doing)
     * @throws {PartyAlreadyJoinedError} The client already joined this party
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched due to a permission error
     * @throws {PartyMaxSizeReachedError} The party has reached its max size
     * @throws {EpicgamesAPIError}
     */
    async join(skipRefresh = false) {
        if (!skipRefresh) {
            await this.fetch();
        }
        if (this.members.get(this.client.user.self.id))
            throw new PartyAlreadyJoinedError_1.default();
        this.client.partyLock.lock();
        if (this.client.party)
            await this.client.party.leave(false);
        try {
            await this.client.http.epicgamesRequest({
                method: 'POST',
                url: `${Endpoints_1.default.BR_PARTY}/parties/${this.id}/members/${this.client.user.self.id}/join`,
                headers: {
                    'Content-Type': 'application/json',
                },
                data: {
                    connection: {
                        id: this.client.xmpp.JID,
                        meta: {
                            'urn:epic:conn:platform_s': this.client.config.platform,
                            'urn:epic:conn:type_s': 'game',
                        },
                        yield_leadership: false,
                    },
                    meta: {
                        'urn:epic:member:dn_s': this.client.user.self.displayName,
                        'urn:epic:member:joinrequestusers_j': JSON.stringify({
                            users: [
                                {
                                    id: this.client.user.self.id,
                                    dn: this.client.user.self.displayName,
                                    plat: this.client.config.platform,
                                    data: JSON.stringify({
                                        CrossplayPreference: '1',
                                        SubGame_u: '1',
                                    }),
                                },
                            ],
                        }),
                    },
                },
            }, enums_1.AuthSessionStoreKey.Fortnite);
        }
        catch (e) {
            this.client.partyLock.unlock();
            await this.client.initParty(true, false);
            throw e;
        }
        this.client.setClientParty(this);
        this.client.partyLock.unlock();
    }
    /**
     * Updates this party's data
     */
    updateData(data) {
        var _a, _b;
        if (data.revision > this.revision)
            this.revision = data.revision;
        this.meta.update((_a = data.party_state_updated) !== null && _a !== void 0 ? _a : {}, true);
        this.meta.remove((_b = data.party_state_removed) !== null && _b !== void 0 ? _b : []);
        this.config.joinability = data.party_privacy_type;
        this.config.maxSize = data.max_number_of_members;
        this.config.subType = data.party_sub_type;
        this.config.type = data.party_type;
        this.config.inviteTtl = data.invite_ttl_seconds;
        this.config.discoverability = data.discoverability;
        let privacy = this.meta.get('Default:PrivacySettings_j');
        privacy = Object.values(Enums_1.PartyPrivacy)
            .find((val) => val.partyType === privacy.PrivacySettings.partyType
            && val.inviteRestriction === privacy.PrivacySettings.partyInviteRestriction
            && val.onlyLeaderFriendsCanJoin === privacy.PrivacySettings.bOnlyLeaderFriendsCanJoin);
        if (privacy)
            this.config.privacy = privacy;
    }
    /**
     * Updates the basic user information (display name and external auths) of all party members
     */
    async updateMemberBasicInfo() {
        const users = await this.client.user.fetchMultiple(this.members.map((m) => m.id));
        users.forEach((u) => { var _a; return (_a = this.members.get(u.id)) === null || _a === void 0 ? void 0 : _a.update(u); });
    }
    /**
     * Refetches this party's data
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched due to a permission error
     * @throws {EpicgamesAPIError}
     */
    async fetch() {
        const partyData = await this.client.getParty(this.id, true);
        this.createdAt = new Date(partyData.created_at);
        this.config = (0, Util_1.makeCamelCase)(partyData.config);
        this.config.privacy = this.config.joinability === 'OPEN' ? Enums_1.PartyPrivacy.PUBLIC : Enums_1.PartyPrivacy.PRIVATE;
        this.meta = new PartyMeta_1.default(partyData.meta);
        this.revision = partyData.revision || 0;
        // eslint-disable-next-line arrow-body-style
        this.members = new collection_1.Collection(partyData.members.map((m) => {
            if (m.account_id === this.client.user.self.id)
                return [m.account_id, new ClientPartyMember_1.default(this, m)];
            return [m.account_id, new PartyMember_1.default(this, m)];
        }));
    }
    /**
     * Converts this party into an object
     */
    toObject() {
        return {
            id: this.id,
            created_at: this.createdAt.toISOString(),
            config: (0, Util_1.makeSnakeCase)(this.config),
            invites: [],
            members: this.members.map((m) => m.toObject()),
            meta: this.meta.schema,
            revision: 0,
            updated_at: new Date().toISOString(),
        };
    }
}
exports.default = Party;
//# sourceMappingURL=Party.js.map