"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const collection_1 = require("@discordjs/collection");
const Base_1 = tslib_1.__importDefault(require("../../client/Base"));
const FriendNotFoundError_1 = tslib_1.__importDefault(require("../../exceptions/FriendNotFoundError"));
const Endpoints_1 = tslib_1.__importDefault(require("../../../resources/Endpoints"));
const UserNotFoundError_1 = tslib_1.__importDefault(require("../../exceptions/UserNotFoundError"));
const DuplicateFriendshipError_1 = tslib_1.__importDefault(require("../../exceptions/DuplicateFriendshipError"));
const FriendshipRequestAlreadySentError_1 = tslib_1.__importDefault(require("../../exceptions/FriendshipRequestAlreadySentError"));
const InviteeFriendshipsLimitExceededError_1 = tslib_1.__importDefault(require("../../exceptions/InviteeFriendshipsLimitExceededError"));
const InviteeFriendshipRequestLimitExceededError_1 = tslib_1.__importDefault(require("../../exceptions/InviteeFriendshipRequestLimitExceededError"));
const InviteeFriendshipSettingsError_1 = tslib_1.__importDefault(require("../../exceptions/InviteeFriendshipSettingsError"));
const OfferNotFoundError_1 = tslib_1.__importDefault(require("../../exceptions/OfferNotFoundError"));
const SendMessageError_1 = tslib_1.__importDefault(require("../../exceptions/SendMessageError"));
const SentFriendMessage_1 = tslib_1.__importDefault(require("./SentFriendMessage"));
class FriendsManager extends Base_1.default {
    constructor(constr) {
        super(constr);
        this.list = new collection_1.Collection();
        this.pendingFriends = new collection_1.Collection();
    }
    /**
     * Sets the clients XMPP status
     * @param status The status
     * @param onlineType The presence's online type (eg "away")
     * @param friend A specific friend you want to send this status to
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     */
    setStatus(status, onlineType, friend) {
        var _a, _b, _c;
        // eslint-disable-next-line no-undef-init
        let toJID = undefined;
        if (friend) {
            const resolvedFriend = this.list.find((f) => f.displayName === friend || f.id === friend);
            if (!resolvedFriend)
                throw new FriendNotFoundError_1.default(friend);
            toJID = `${resolvedFriend.id}@${Endpoints_1.default.EPIC_PROD_ENV}`;
        }
        // eslint-disable-next-line no-undef-init
        let partyJoinInfoData = undefined;
        if (this.client.party) {
            const partyPrivacy = this.client.party.config.privacy;
            if (partyPrivacy.presencePermission === 'Noone'
                || (partyPrivacy.presencePermission === 'Leader'
                    && !((_a = this.client.party.me) === null || _a === void 0 ? void 0 : _a.isLeader))) {
                partyJoinInfoData = {
                    isPrivate: true,
                };
            }
            else {
                partyJoinInfoData = {
                    sourceId: (_b = this.client.user) === null || _b === void 0 ? void 0 : _b.id,
                    sourceDisplayName: (_c = this.client.user) === null || _c === void 0 ? void 0 : _c.displayName,
                    sourcePlatform: this.client.config.platform,
                    partyId: this.client.party.id,
                    partyTypeId: 286331153,
                    key: 'k',
                    appId: 'Fortnite',
                    buildId: this.client.config.partyBuildId,
                    partyFlags: -2024557306,
                    notAcceptingReason: 0,
                    pc: this.client.party.size,
                };
            }
        }
        if (status && !toJID)
            this.client.config.defaultStatus = status;
        if (onlineType && !toJID)
            this.client.config.defaultOnlineType = onlineType;
        const rawStatus = {
            Status: status
                || this.client.config.defaultStatus
                || (this.client.party
                    && `Battle Royale Lobby - ${this.client.party.size} / ${this.client.party.maxSize}`)
                || 'Playing Battle Royale',
            bIsPlaying: false,
            bIsJoinable: this.client.party
                && !this.client.party.isPrivate
                && this.client.party.size !== this.client.party.maxSize,
            bHasVoiceSupport: false,
            SessionId: '',
            ProductName: 'Fortnite',
            Properties: {
                'party.joininfodata.286331153_j': partyJoinInfoData,
                FortBasicInfo_j: {
                    homeBaseRating: 0,
                },
                FortLFG_I: '0',
                FortPartySize_i: 1,
                FortSubGame_i: 1,
                InUnjoinableMatch_b: false,
                FortGameplayStats_j: {
                    state: '',
                    playlist: 'None',
                    numKills: 0,
                    bFellToDeath: false,
                },
            },
        };
        const rawOnlineType = (onlineType || this.client.config.defaultOnlineType) === 'online'
            ? undefined
            : onlineType || this.client.config.defaultOnlineType;
        return this.client.xmpp.sendStatus(rawStatus, rawOnlineType, toJID);
    }
    /**
     * Resets the client's XMPP status and online type
     */
    async resetStatus() {
        this.client.config.defaultStatus = undefined;
        this.client.config.defaultOnlineType = 'online';
        return this.setStatus();
    }
    /**
     * Sends a friendship request to a user or accepts an existing request
     * @param friend The id or display name of the user to add
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {DuplicateFriendshipError} The user is already friends with the client
     * @throws {FriendshipRequestAlreadySentError} A friendship request has already been sent to the user
     * @throws {InviterFriendshipsLimitExceededError} The client's friendship limit is reached
     * @throws {InviteeFriendshipsLimitExceededError} The user's friendship limit is reached
     * @throws {InviteeFriendshipSettingsError} The user disabled friend requests
     * @throws {InviteeFriendshipRequestLimitExceededError} The user's incoming friend request limit is reached
     * @throws {EpicgamesAPIError}
     */
    async add(friend) {
        var _a;
        const userID = await this.resolveUserId(friend);
        if (!userID)
            throw new UserNotFoundError_1.default(friend);
        const addFriend = await this.client.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.FRIEND_ADD}/${(_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id}/${userID}`, 'fortnite');
        if (addFriend.error) {
            switch (addFriend.error.code) {
                case 'errors.com.epicgames.friends.duplicate_friendship':
                    throw new DuplicateFriendshipError_1.default(friend);
                case 'errors.com.epicgames.friends.friend_request_already_sent':
                    throw new FriendshipRequestAlreadySentError_1.default(friend);
                case 'errors.com.epicgames.friends.inviter_friendships_limit_exceeded':
                    throw new InviteeFriendshipsLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.invitee_friendships_limit_exceeded':
                    throw new InviteeFriendshipsLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.incoming_friendships_limit_exceeded':
                    throw new InviteeFriendshipRequestLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.cannot_friend_due_to_target_settings':
                    throw new InviteeFriendshipSettingsError_1.default(friend);
                case 'errors.com.epicgames.friends.account_not_found':
                    throw new UserNotFoundError_1.default(friend);
                default:
                    throw addFriend.error;
            }
        }
    }
    /**
     * Removes a friend from the client's friend list or declines / aborts a pending friendship request
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async remove(friend) {
        var _a;
        let resolvedFriend;
        resolvedFriend = this.list.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend) {
            resolvedFriend = this.pendingFriends.find((f) => f.displayName === friend || f.id === friend);
        }
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const removeFriend = await this.client.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.FRIEND_DELETE}/${(_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id}/friends/${resolvedFriend.id}`, 'fortnite');
        if (removeFriend.error)
            throw removeFriend.error;
    }
    /**
     * Fetches the friends the client shares with a friend
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async getMutual(friend) {
        var _a;
        const resolvedFriend = this.list.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const mutualFriends = await this.client.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.FRIENDS}/${(_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id}/friends/${resolvedFriend.id}/mutual`, 'fortnite');
        if (mutualFriends.error)
            throw mutualFriends.error;
        return mutualFriends.response
            .map((f) => this.list.get(f))
            .filter((f) => !!f);
    }
    /**
     * Checks whether a friend owns a specific offer
     * @param friend The id or display name of the friend
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async checkOfferOwnership(friend, offerId) {
        const resolvedFriend = this.list.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const giftData = await this.client.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_GIFT_ELIGIBILITY}/recipient/${resolvedFriend.id}`
            + `/offer/${encodeURIComponent(offerId)}`, 'fortnite');
        if (giftData.error) {
            if (giftData.error.code
                === 'errors.com.epicgames.modules.gamesubcatalog.catalog_out_of_date') {
                throw new OfferNotFoundError_1.default(offerId);
            }
            if (giftData.error.code
                === 'errors.com.epicgames.modules.gamesubcatalog.purchase_not_allowed') {
                return true;
            }
            throw giftData.error;
        }
        return false;
    }
    /**
     * Blocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async block(user) {
        var _a;
        const userID = await this.resolveUserId(user);
        if (!userID)
            throw new UserNotFoundError_1.default(user);
        const blockUser = await this.client.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.FRIEND_BLOCK}/${(_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id}/${userID}`, 'fortnite');
        if (blockUser.error)
            throw blockUser.error;
    }
    /**
     * Unblocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async unblock(user) {
        var _a;
        const blockedUser = this.client.blockedUsers.find((u) => u.displayName === user || u.id === user);
        if (!blockedUser)
            throw new UserNotFoundError_1.default(user);
        const unblockUser = await this.client.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.FRIEND_BLOCK}/${(_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id}/${blockedUser.id}`, 'fortnite');
        if (unblockUser.error)
            throw unblockUser.error;
    }
    /**
     * Sends a message to a friend
     * @param friend The id or display name of the friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {SendMessageError} The messant could not be sent
     */
    async sendMessage(friend, content) {
        const resolvedFriend = this.list.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        if (!this.client.xmpp.isConnected) {
            throw new SendMessageError_1.default("You're not connected via XMPP", 'FRIEND', resolvedFriend);
        }
        const message = await this.client.xmpp.sendMessage(`${resolvedFriend.id}@${Endpoints_1.default.EPIC_PROD_ENV}`, content);
        if (!message) {
            throw new SendMessageError_1.default('Message timeout exceeded', 'FRIEND', resolvedFriend);
        }
        return new SentFriendMessage_1.default(this.client, {
            author: this.client.user,
            content,
            id: message.id,
            sentAt: new Date(),
        });
    }
    /**
     * Resolves a single user id
     * @param query Display name or id of the account's id to resolve
     */
    async resolveUserId(query) {
        var _a;
        if (query.length === 32)
            return query;
        return (_a = (await this.client.getProfile(query))) === null || _a === void 0 ? void 0 : _a.id;
    }
}
exports.default = FriendsManager;
//# sourceMappingURL=FriendManager.js.map