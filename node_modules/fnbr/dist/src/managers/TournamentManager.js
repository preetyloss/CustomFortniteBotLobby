"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const Base_1 = tslib_1.__importDefault(require("../Base"));
const MatchNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/MatchNotFoundError"));
const EventTokens_1 = tslib_1.__importDefault(require("../structures/EventTokens"));
const Tournament_1 = tslib_1.__importDefault(require("../structures/Tournament"));
const enums_1 = require("../../resources/enums");
/**
 * Represent's the client's tournament manager.
 */
class TournamentManager extends Base_1.default {
    /**
     * Downloads a file from the CDN (used for replays)
     * @param url The URL of the file to download
     * @param responseType The response type
     */
    async downloadReplayCDNFile(url, responseType) {
        const fileLocationInfo = await this.client.http.epicgamesRequest({
            method: 'GET',
            url,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        const file = await this.client.http.request({
            method: 'GET',
            url: Object.values(fileLocationInfo.files)[0].readLink,
            responseType,
        });
        return file;
    }
    /**
     * Fetches the event tokens for an account.
     * This can be used to check if a user is eligible to play a certain tournament window
     * or to check a user's arena division in any season
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async getEventTokens(user) {
        const users = typeof user === 'string' ? [user] : user;
        const resolvedUsers = await this.client.user.fetchMultiple(users);
        const userChunks = resolvedUsers.map((u) => u.id).reduce((resArr, usr, i) => {
            const chunkIndex = Math.floor(i / 16);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(usr);
            return resArr;
        }, []);
        const statsResponses = await Promise.all(userChunks.map((c) => this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.BR_TOURNAMENT_TOKENS}?teamAccountIds=${c.join(',')}`,
        }, enums_1.AuthSessionStoreKey.Fortnite)));
        return statsResponses.map((r) => r.accounts).flat(1)
            .map((r) => new EventTokens_1.default(this.client, r.tokens, resolvedUsers.find((u) => u.id === r.accountId)));
    }
    /**
     * Fetches the current and past Battle Royale tournaments
     * @param region The region
     * @param platform The platform
     * @throws {EpicgamesAPIError}
     */
    async get(region = 'EU', platform = 'Windows') {
        const [tournaments, tournamentsInfo] = await Promise.all([
            this.client.http.epicgamesRequest({
                method: 'GET',
                url: `${Endpoints_1.default.BR_TOURNAMENTS_DOWNLOAD}/${this.client.user.self.id}?region=${region}`
                    + `&platform=${platform}&teamAccountIds=${this.client.user.self.id}`,
            }, enums_1.AuthSessionStoreKey.Fortnite),
            this.client.http.epicgamesRequest({
                method: 'GET',
                url: `${Endpoints_1.default.BR_NEWS}/tournamentinformation`,
            }, enums_1.AuthSessionStoreKey.Fortnite),
        ]);
        const constuctedTournaments = [];
        tournaments.events.forEach((t) => {
            var _a, _b, _c;
            let tournamentDisplayData = (_b = (_a = tournamentsInfo.tournament_info) === null || _a === void 0 ? void 0 : _a.tournaments) === null || _b === void 0 ? void 0 : _b.find((td) => td.tournament_display_id === t.displayDataId);
            if (!tournamentDisplayData) {
                tournamentDisplayData = (_c = Object.values(tournamentsInfo)
                    .find((tdr) => { var _a; return ((_a = tdr.tournament_info) === null || _a === void 0 ? void 0 : _a.tournament_display_id) === t.displayDataId; })) === null || _c === void 0 ? void 0 : _c.tournament_info;
            }
            if (!tournamentDisplayData) {
                return;
            }
            const templates = [];
            t.eventWindows.forEach((w) => {
                const template = tournaments.templates
                    .find((tt) => tt.eventTemplateId === w.eventTemplateId);
                if (template)
                    templates.push({ windowId: w.eventWindowId, templateData: template });
            });
            constuctedTournaments.push(new Tournament_1.default(this.client, t, tournamentDisplayData, templates));
        });
        return constuctedTournaments;
    }
    async getData() {
        const tournaments = await this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.BR_TOURNAMENTS}/${this.client.user.self.id}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        const tournamentsInfo = await this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.BR_NEWS}/tournamentinformation`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        const constuctedTournaments = [];
        tournaments.events.forEach((t) => {
            var _a, _b, _c;
            let tournamentDisplayData = (_b = (_a = tournamentsInfo.tournament_info) === null || _a === void 0 ? void 0 : _a.tournaments) === null || _b === void 0 ? void 0 : _b.find((td) => td.tournament_display_id === t.displayDataId);
            if (!tournamentDisplayData) {
                tournamentDisplayData = (_c = Object.values(tournamentsInfo)
                    .find((tdr) => { var _a; return ((_a = tdr.tournament_info) === null || _a === void 0 ? void 0 : _a.tournament_display_id) === t.displayDataId; })) === null || _c === void 0 ? void 0 : _c.tournament_info;
            }
            if (!tournamentDisplayData) {
                return;
            }
            const templates = [];
            t.eventWindows.forEach((w) => {
                const template = tournaments.templates
                    .find((tt) => tt.eventTemplateId === w.eventTemplateId);
                if (template)
                    templates.push({ windowId: w.eventWindowId, templateData: template });
            });
            constuctedTournaments.push(new Tournament_1.default(this.client, t, tournamentDisplayData, templates));
        });
        return constuctedTournaments;
    }
    /**
     * Fetches a tournament session's metadata
     * @param sessionId The session ID
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    async getSessionMetadata(sessionId) {
        var _a, _b;
        let replayMetadataResponse;
        try {
            replayMetadataResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY_METADATA}%2F${sessionId}.json`, 'json');
        }
        catch (e) {
            if (e instanceof axios_1.AxiosError && typeof ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) === 'string'
                && ((_b = e.response) === null || _b === void 0 ? void 0 : _b.data.includes('<Message>The specified key does not exist.</Message>'))) {
                throw new MatchNotFoundError_1.default(sessionId);
            }
            throw e;
        }
        return {
            changelist: replayMetadataResponse.Changelist,
            checkpoints: replayMetadataResponse.Checkpoints,
            dataChunks: replayMetadataResponse.DataChunks,
            desiredDelayInSeconds: replayMetadataResponse.DesiredDelayInSeconds,
            events: replayMetadataResponse.Events,
            friendlyName: replayMetadataResponse.FriendlyName,
            lengthInMS: replayMetadataResponse.LengthInMS,
            networkVersion: replayMetadataResponse.NetworkVersion,
            replayName: replayMetadataResponse.ReplayName,
            timestamp: new Date(replayMetadataResponse.Timestamp),
            isCompressed: replayMetadataResponse.bCompressed,
            isLive: replayMetadataResponse.bIsLive,
        };
    }
    /**
     * Fetches the results for a tournament window
     * @param eventId The tournament's ID
     * @param eventWindowId The tournament window's ID
     * @param showLiveSessions Whether to show live sessions
     * @param page The results page index
     * @throws {EpicgamesAPIError}
     */
    async getWindowResults(eventId, eventWindowId, showLiveSessions = false, page = 0) {
        const window = await this.client.http.epicgamesRequest({
            method: 'GET',
            url: `${Endpoints_1.default.BR_TOURNAMENT_WINDOW}/${eventId}/${eventWindowId}/`
                + `${this.client.user.self.id}?page=${page}&rank=0&teamAccountIds=&appId=Fortnite&showLiveSessions=${showLiveSessions}`,
        }, enums_1.AuthSessionStoreKey.Fortnite);
        return window;
    }
}
exports.default = TournamentManager;
//# sourceMappingURL=TournamentManager.js.map